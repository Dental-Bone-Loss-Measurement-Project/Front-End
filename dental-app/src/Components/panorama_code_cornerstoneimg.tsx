import React, { useState, ChangeEvent, useEffect, useRef } from 'react';
import axios from 'axios';
import {
  RenderingEngine,
  Enums,
  getRenderingEngine,
  init,
  imageLoader,
  Types,
} from '@cornerstonejs/core';
import * as cornerstoneTools from '@cornerstonejs/tools';
// Ensure VOILUTFunctionType is imported correctly
import { VOILUTFunctionType } from '@cornerstonejs/core/enums';
// Import RGB type if needed for defaultOptions.background
import { type RGB } from '@cornerstonejs/core/types';

// Type alias for the image loader function
type ImageLoaderFn = (imageId: string) => {
  promise: Promise<Types.IImage>;
  cancelFn?: () => void;
  decache?: () => void;
};

const {
  LengthTool,
  BidirectionalTool,
  ArrowAnnotateTool,
  EraserTool,
  ToolGroupManager,
  Enums: csToolsEnums,
} = cornerstoneTools;

const { ViewportType } = Enums;
const { MouseBindings } = csToolsEnums;

// Update the response interface to potentially include pixel spacing
interface UploadResponse {
  imageShape: [number, number, number]; // Shape of the original CBCT volume (metadata from backend)
  panoramicViewUrl: string; // URL to the panoramic image file (e.g., PNG, JPG) generated by backend
  pixelSpacingX?: number; // Horizontal pixel spacing of the panoramic image (mm/pixel) - CRITICAL for measurements
  pixelSpacingY?: number; // Vertical pixel spacing of the panoramic image (mm/pixel) - CRITICAL for measurements
}

const ImageUpload: React.FC = () => {
  const [file, setFile] = useState<File | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<string>('');
  const [responseData, setResponseData] = useState<UploadResponse | null>(null);
  const [activeTool, setActiveTool] = useState<string>(LengthTool.toolName);
  const elementRef = useRef<HTMLDivElement>(null); // Ref for the HTML element Cornerstone will render into
  const renderingEngineId = 'panoramaEngine'; // Unique ID for the rendering engine
  const viewportId = 'PANORAMA_VIEWPORT';     // Unique ID for the viewport
  const toolGroupId = 'PANORAMA_TOOLS';       // Unique ID for the tool group

  // 1. Initialize Cornerstone and Add Tools/ToolGroup
  // This effect runs once when the component mounts to set up the Cornerstone environment.
  useEffect(() => {
    const initializeCornerstone = async () => {
      // Initialize Cornerstone.js and CornerstoneTools
      await init();
      cornerstoneTools.init();
      console.log('Cornerstone Initialized');

      // Add the required tools to the Cornerstone Tools library
      cornerstoneTools.addTool(LengthTool);
      cornerstoneTools.addTool(BidirectionalTool);
      cornerstoneTools.addTool(ArrowAnnotateTool);
      cornerstoneTools.addTool(EraserTool);
      console.log('Cornerstone Tools Added');


      // Create a tool group to manage the tools applied to specific viewports
      const toolGroup = ToolGroupManager.createToolGroup(toolGroupId);
      if (toolGroup) {
        // Add the tools to the tool group
        toolGroup.addTool(LengthTool.toolName);
        toolGroup.addTool(BidirectionalTool.toolName);
        toolGroup.addTool(ArrowAnnotateTool.toolName);
        toolGroup.addTool(EraserTool.toolName);
        console.log(`Tool group "${toolGroupId}" created and tools added.`);


        // Set the initial active tool (Length) and bind it to the primary mouse button (left click)
        // This ensures a tool is ready to use as soon as a viewport is added to this group.
        toolGroup.setToolActive(LengthTool.toolName, { bindings: [{ mouseButton: MouseBindings.Primary }] });
         console.log(`Initial active tool set: ${LengthTool.toolName}`);

      } else {
          console.error(`Failed to create tool group: ${toolGroupId}`);
      }
    };

    initializeCornerstone();

    // Cleanup function for the first effect: runs when the component unmounts.
    // It cleans up Cornerstone resources to prevent memory leaks.
    return () => {
        console.log('Component unmounting, starting Cornerstone cleanup...');
        // Get the rendering engine instance
        const engine = getRenderingEngine(renderingEngineId);
        if (engine) {
            try {
                // Disable the HTML element associated with the viewport.
                // This removes event listeners and cleans up the WebGL context for that element.
                engine.disableElement(viewportId);
                 console.log(`Cleaned up Cornerstone viewport: ${viewportId}`);
                // Depending on your application's structure, you might destroy the engine
                // if this component is the only one using it. Use cautiously.
                 // engine.destroy();
            } catch(e) {
                 console.warn('Error during Cornerstone viewport cleanup:', e);
            }
        }
         // Also destroy the tool group to release its resources
         ToolGroupManager.destroyToolGroup(toolGroupId);
         console.log(`Destroyed tool group: ${toolGroupId}`);

         // Note: cornerstoneTools.destroy() and cornerstone.shutdown() exist
         // but might be too aggressive if Cornerstone is used elsewhere in your app.
         // Disabling elements and destroying tool groups is usually sufficient
         // for component-level cleanup.
    };
  }, []); // Empty dependency array: this effect runs only once on component mount.

  // 2. Load image and setup viewport when panorama data is available from the backend response.
  // This effect runs whenever `responseData` or `activeTool` changes.
  useEffect(() => {
    const setupViewportAndImage = async () => {
      // Exit early if we don't have the panoramic image URL or the DOM element is not ready
      if (!responseData?.panoramicViewUrl || !elementRef.current) {
        console.log('setupViewportAndImage: Response data or element not ready. Skipping setup.');
        // Return a synchronous cleanup function that does nothing if setup is skipped
        return () => { console.log('setupViewportAndImage cleanup: Setup skipped, nothing to clean.'); };
      }

      // Define the custom image loader for 'panorama:' prefixed imageIds.
      // This loader tells Cornerstone how to get pixel data for images identified by 'panorama:'.
      // It must return an object with a 'promise' property.
      // Removed explicit type annotation to potentially resolve type conflict issues.
      const panoramaLoader: ImageLoaderFn = (imageId: string) => {
        // Extract the actual URL from the imageId (e.g., 'panorama:http://...')
        const url = imageId.replace('panorama:', '');

        // Create an async function that performs the actual loading work
        const loadingPromise = (async () => {
            try {
              // 1. Fetch the image data (assuming it's a standard image file like PNG/JPG).
              console.log(`panoramaLoader: Fetching panoramic image from: ${url}`);
              const response = await fetch(url);
              if (!response.ok) {
                throw new Error(`Failed to fetch image: ${response.status} ${response.statusText}`);
              }
              const blob = await response.blob(); // Get the response body as a Blob
               console.log('panoramaLoader: Image fetched successfully.');


              // 2. Create an ImageBitmap from the Blob. This is an efficient way to decode images in the browser.
              const imageBitmap = await createImageBitmap(blob);
              console.log(`panoramaLoader: Image decoded: ${imageBitmap.width}x${imageBitmap.height}`);


              // 3. Create a temporary canvas to draw the ImageBitmap and get its raw pixel data.
              const canvas = document.createElement('canvas');
              canvas.width = imageBitmap.width;
              canvas.height = imageBitmap.height;
              const ctx = canvas.getContext('2d');
              if (!ctx) {
                throw new Error('Failed to get canvas context');
              }
              ctx.drawImage(imageBitmap, 0, 0); // Draw the decoded image onto the canvas
               console.log('panoramaLoader: Image drawn onto temporary canvas.');


              // 4. Get the raw RGBA pixel data from the canvas.
              const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
              const rgbaPixelData = imageData.data; // This is a Uint8ClampedArray (R, G, B, A, R, G, B, A, ...)
               console.log(`panoramaLoader: Extracted ${rgbaPixelData.length} RGBA pixel data bytes.`);

              // 5. Convert the RGBA data to a single channel (grayscale Uint8Array) for Cornerstone's STACK viewport.
              // Cornerstone's STACK viewport typically works best with single-channel (grayscale) data.
              // We'll take the Red channel value as the grayscale value (a common approach for display).
              const grayscalePixelData = new Uint8Array(imageBitmap.width * imageBitmap.height);
              let minVal = 255; // Initialize min/max to find the actual data range
              let maxVal = 0;

              for (let i = 0; i < grayscalePixelData.length; i++) {
                const val = rgbaPixelData[i * 4]; // Get the Red channel value
                grayscalePixelData[i] = val;
                 // Track min/max values in the grayscale data to set a default window level
                 if (val < minVal) minVal = val;
                 if (val > maxVal) maxVal = val;
              }
               console.log(`panoramaLoader: Converted to grayscale, detected minPixelValue: ${minVal}, maxPixelValue: ${maxVal}`);


              // 6. Construct the Cornerstone Image object (Types.IImage).
              // This object contains all the information Cornerstone needs to render the image and apply tools.
              const cornerstoneImage: Types.IImage = {
                imageId: imageId, // The ID used to load this image ('panorama:...')
                minPixelValue: Math.max(0, minVal),
                maxPixelValue: Math.min(255, maxVal),
                slope: 1, // Standard for raw pixel data unless scaling is applied
                intercept: 0, // Standard for raw pixel data unless scaling is applied
                rows: imageBitmap.height,   // Height of the image in pixels
                columns: imageBitmap.width, // Width of the image in pixels
                height: imageBitmap.height, // Redundant, but often included
                width: imageBitmap.width,   // Redundant, but often included
                color: false, // Set to false because we converted to grayscale single channel
                columnPixelSpacing: responseData.pixelSpacingX || 1, // mm per pixel horizontally
                rowPixelSpacing: responseData.pixelSpacingY || 1,   // mm per pixel vertically
                sizeInBytes: grayscalePixelData.byteLength, // Size of the pixel data array in bytes
                getPixelData: () => grayscalePixelData, // A function that returns the pixel data array
                getCanvas: () => {
                  const canvas = document.createElement('canvas');
                  canvas.width = imageBitmap.width;
                  canvas.height = imageBitmap.height;
                  const ctx = canvas.getContext('2d');
                  if (ctx) {
                    const imageData = new ImageData(new Uint8ClampedArray(grayscalePixelData.buffer), imageBitmap.width, imageBitmap.height);
                    ctx.putImageData(imageData, 0, 0);
                  }
                  return canvas;
                },
                rgba: false,
                numberOfComponents: 1,
                invert: false,
                dataType: 'Uint8Array', // Standard linear mapping of pixel values to display values
                voiLUTFunction: VOILUTFunctionType.LINEAR_EXACT, // Standard linear mapping of pixel values to display values
                windowCenter: (minVal + maxVal) / 2, // Center of the window
                windowWidth: maxVal - minVal,       // Width of the window
              };

              // Log the final image object before resolving the loader promise
               console.log('panoramaLoader: Constructed Cornerstone Image object:', cornerstoneImage);

              // Resolve the promise with the constructed image object
              return cornerstoneImage;

            } catch (error) {
              console.error('panoramaLoader: Error loading image:', error);
              const errorMsg = error instanceof Error ? error.message : String(error);
              // Update the component's error state
              setError(`Error loading panoramic image: ${errorMsg}`);
              // Reject the promise
              throw error;
            }
        })(); // Immediately invoke the async function

        // Return the object with the promise property, as expected by registerImageLoader
        return {
            promise: loadingPromise as Promise<Types.IImage>,
            // Optional: add cancelFn and decache if your loader supports them
            cancelFn: undefined,
            decache: undefined,
        };
      };

      // Register the custom image loader with Cornerstone's imageLoader module.
      // This tells Cornerstone to use `panoramaLoader` whenever it encounters an imageId starting with 'panorama:'.
      //  imageLoader.registerImageLoader('panorama', panoramaLoader);
      console.log('Image loading effect: Panorama image loader registered.');


      // Get or create the rendering engine instance.
      // We check if an engine with this ID already exists (e.g., from a previous image load).
      let renderingEngine = getRenderingEngine(renderingEngineId);
      if (renderingEngine) {
          console.log(`Image loading effect: Rendering engine "${renderingEngineId}" already exists.`);
          try {
             // If the engine exists, disable the old viewport element.
             // This cleans up the previous rendering context and event listeners for the element.
             renderingEngine.disableElement(viewportId);
             console.log(`Image loading effect: Disabled old viewport "${viewportId}".`);
             // In some scenarios, you might want to destroy and recreate the engine here,
             // but disabling the element is often sufficient for switching images in a single viewport.
             // renderingEngine.destroy();
             // renderingEngine = new RenderingEngine(renderingEngineId); // If destroying
          } catch (e) {
              console.warn('Image loading effect: Error disabling existing viewport:', e);
              // If disabling fails, proceed with getting the engine instance.
              // getRenderingEngine will return undefined if the engine was somehow destroyed.
          }
           // After potential disable/destroy, re-get the engine instance
           renderingEngine = getRenderingEngine(renderingEngineId);
            if (!renderingEngine) {
                // If the engine was not found or was destroyed, create a new one.
                 renderingEngine = new RenderingEngine(renderingEngineId);
                 console.log(`Image loading effect: Re-created rendering engine "${renderingEngineId}" after check.`);
            }

      } else {
          // If the engine doesn't exist, create a new one.
          renderingEngine = new RenderingEngine(renderingEngineId);
          console.log(`Image loading effect: Created new rendering engine "${renderingEngineId}".`);
      }


      // Define the input configuration for the viewport.
      const viewportInput = {
        viewportId, // The unique ID for this viewport
        type: ViewportType.STACK, // Use STACK type for displaying a single image
        element: elementRef.current, // The HTML element to render into
        defaultOptions: {
            background: [0, 0, 0] as RGB, // Set a black background (ensure RGB type is imported or remove `: RGB`)
        }
      };

      let viewport: Types.IStackViewport; // Declare viewport variable

      try {
           // Enable the HTML element for Cornerstone rendering based on the viewport input config.
           renderingEngine.enableElement(viewportInput);
           console.log(`Image loading effect: Enabled viewport element "${viewportId}".`);

           // Get the created viewport instance.
           viewport = renderingEngine.getViewport(viewportId) as Types.IStackViewport;

           // Set the image to be displayed in the viewport.
           // We use the 'panorama:' prefix with the URL to trigger our custom loader.
           const imageId = `panorama:${responseData.panoramicViewUrl}`;
           console.log(`Image loading effect: Attempting to set stack with imageId: ${imageId}`);

           // setStack is an async operation as it involves fetching the image via the loader.
           // The loader returns { promise: Promise<IImage> }, and setStack awaits that promise.
           await viewport.setStack([imageId]);
           console.log(`Image loading effect: Stack set successfully with image.`);

           // Render the image in the viewport.
           viewport.render();
           console.log('Image loading effect: Viewport rendered.');

           // Add the viewport to the tool group.
           // This step is crucial for the tools to know which viewport element they should apply to.
           const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);
           if (toolGroup) {
                // Add the viewport to the tool group. It's safe to call this even if it was added before.
                toolGroup.addViewport(viewportId, renderingEngineId);
                console.log(`Image loading effect: Viewport "${viewportId}" added to tool group "${toolGroupId}".`);

                // Ensure the *currently active* tool state is applied to this viewport.
                // This handles cases where the user might have selected a tool before the image finished loading.
                 toolGroup.setToolActive(activeTool, { bindings: [{ mouseButton: MouseBindings.Primary }] });
                 console.log(`Image loading effect: Set active tool "${activeTool}" on tool group after image load.`);

           } else {
               console.error(`Image loading effect: Tool group "${toolGroupId}" not found after rendering.`);
           }

      } catch (loadError) {
          console.error('Image loading effect: Error setting up viewport or loading image:', loadError);
          const errorMsg = loadError instanceof Error ? loadError.message : String(loadError);
          setError(`Failed to set up image viewer: ${errorMsg}`);

           // Clean up the engine/viewport if setup failed midway to prevent resources from being held.
           // Check if renderingEngine and viewport were successfully created before trying to disable.
           if (renderingEngine && renderingEngine.getViewport(viewportId)) {
               try {
                    renderingEngine.disableElement(viewportId);
                    console.log(`Image loading effect: Disabled viewport "${viewportId}" during error cleanup.`);
               } catch(e) {
                    console.warn('Image loading effect: Error during failed setup cleanup (disable viewport):', e);
               }
           } else if (renderingEngine && elementRef.current) {
               // If viewport wasn't fully created but the element was enabled
               try {
                    // Try disabling the element anyway
                    renderingEngine.disableElement(viewportId);
                     console.log(`Image loading effect: Disabled element "${viewportId}" during error cleanup.`);
               } catch(e) {
                    console.warn('Image loading effect: Error during failed setup cleanup (disable element):', e);
               }
           }
      }

      // Return a cleanup function specific to this setup operation.
      // This function will be called by React when the dependencies (`responseData`, `activeTool`) change
      // or when the component unmounts. It cleans up the viewport and its tool group association.
      return () => {
          console.log(`Image loading effect cleanup: Starting cleanup for viewport "${viewportId}".`);
          const engine = getRenderingEngine(renderingEngineId);
          if (engine) {
              try {
                   // Remove the viewport from the tool group first
                   const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);
                   // Use removeViewports which accepts arrays or single IDs for robustness
                   toolGroup?.removeViewports(viewportId, renderingEngineId);
                   console.log(`Image loading effect cleanup: Removed viewport "${viewportId}" from tool group.`);

                   // Disable the element, removing its event listeners and rendering context
                   engine.disableElement(viewportId);
                   console.log(`Image loading effect cleanup: Disabled viewport element "${viewportId}".`);

              } catch (e) {
                   console.warn('Image loading effect cleanup: Error during cleanup:', e);
              }
          }
      };
    };

    // Call the async setup function
    // This initiates the async process and returns a Promise<() => void>
    const setupPromise = setupViewportAndImage();

    // The effect's cleanup function must be synchronous.
    // We return a synchronous function that schedules the actual cleanup logic
    // to run asynchronously once the setupPromise resolves.
     return () => {
         // The setupPromise will eventually resolve with the cleanup function
         // or reject if setup failed. We handle both cases.
         setupPromise.then(cleanupFn => {
             // This callback runs if setupPromise resolved successfully.
             // cleanupFn is the synchronous cleanup function returned by setupViewportAndImage.
             if (cleanupFn) { // Should always be true as setupViewportAndImage returns a function
                 cleanupFn(); // Call the actual cleanup logic
             }
         }).catch(e => {
             // This callback runs if setupPromise was rejected (e.g., image fetch failed).
             // The setup failed, so there's nothing to clean up from a successful setup.
             // The error was already logged and set in the state within setupViewportAndImage.
             console.warn('Image loading effect cleanup: Setup promise rejected, no successful setup to clean.', e);
         });

         // The effect's cleanup function itself does not need to return anything.
         // Its purpose is just to ensure the cleanup logic is scheduled.
     };

  }, [responseData, activeTool]); // Effect dependencies: re-run if responseData (new image) or activeTool changes


  // Handler for file input change
  const handleFileChange = (e: ChangeEvent<HTMLInputElement>) => {
    if (e.target.files && e.target.files.length > 0) {
      const selectedFile = e.target.files[0];
      setFile(selectedFile);
      // Clear previous response data when a new file is selected.
      // This triggers the image loading effect to clean up the old image.
      setResponseData(null);
      setError(''); // Clear previous errors
      console.log('File selected:', selectedFile.name);
    }
  };

  // Handler for the Upload button click
  const handleUpload = async () => {
    if (!file) {
        setError('Please select a file to upload.');
        return;
    }
    setLoading(true); // Set loading state
    setError(''); // Clear previous errors
    const formData = new FormData(); // Create form data to send the file
    formData.append('file', file); // Append the selected file

    try {
      console.log('Uploading file...');
      // Send the file to the backend endpoint using axios
      const response = await axios.post<UploadResponse>(
        'http://localhost:8000/upload-image', // Ensure this URL is correct and your backend is running
        formData,
        { headers: { 'Content-Type': 'multipart/form-data' } } // Set content type for file upload
      );
      console.log('Upload successful, received data:', response.data);
      // Store the response data (including the panoramic image URL and spacing).
      // This state update triggers the second useEffect to load the image.
      setResponseData(response.data);
      // Keep the current active tool. It will be reapplied in the useEffect after the new image loads.
      // setActiveTool(LengthTool.toolName); // Optional: uncomment to reset to the default tool after upload

    } catch (err) {
      console.error('Error uploading or processing image:', err);
      // Provide a more user-friendly error message based on the axios error details
      if (axios.isAxiosError(err)) {
           if (err.response) {
                // The request was made and the server responded with a status code outside 2xx
                console.error('Response data:', err.response.data);
                console.error('Response status:', err.response.status);
                console.error('Response headers:', err.response.headers);
                 setError(`Server responded with error: ${err.response.status} - ${err.response.data?.detail || err.message || 'Unknown server error'}`);
           } else if (err.request) {
                // The request was made but no response was received (e.g., backend is down)
                console.error('Request data:', err.request);
                setError('No response received from server. Is the backend running and accessible at http://localhost:8000?');
           } else {
                // Something happened in setting up the request that triggered an Error
                setError(`An error occurred while setting up the upload request: ${err.message}`);
           }
      } else {
           // Any other non-axios error
           setError(`An unexpected error occurred during upload: ${err instanceof Error ? err.message : String(err)}`);
      }
    } finally {
      setLoading(false); // Hide loading indicator
    }
  };

  // Handler for clicking the tool buttons
  const handleToolChange = (toolName: string) => {
    console.log(`Attempting to set active tool to: ${toolName}`);
    setActiveTool(toolName); // Update local state for UI highlighting

    // Get the tool group instance
    const toolGroup = ToolGroupManager.getToolGroup(toolGroupId);
    if (toolGroup) {
      // Set the selected tool as active for the primary mouse button (left click).
      // Cornerstone Tools automatically deactivates any other tool previously bound to the same button.
      toolGroup.setToolActive(toolName, { bindings: [{ mouseButton: MouseBindings.Primary }] });
      console.log(`Tool "${toolName}" set to active on tool group.`);
    } else {
        console.error(`Tool group "${toolGroupId}" not found when changing tool.`);
    }
  };

  // Handler for saving the annotated image
  const handleSaveImage = () => {
    if (elementRef.current) {
      // Find the canvas element that Cornerstone renders into within the viewport div
      const canvas = elementRef.current.querySelector('canvas');
      if (canvas) {
        try {
             // Create a temporary anchor element to trigger the download
             const link = document.createElement('a');
             link.download = 'annotated-panorama.png'; // Set the default file name

             // Get the data URL of the canvas content (this includes the image and any annotations drawn on it)
             // Specify 'image/png' to get a PNG formatted data URL
             link.href = canvas.toDataURL('image/png');

             // Append the link to the document body, programmatically click it, and then remove it
             document.body.appendChild(link);
             link.click();
             document.body.removeChild(link);

             console.log('Saved image as annotated-panorama.png');
        } catch(e) {
             console.error('Error saving image:', e);
             setError('Failed to save image.');
        }
      } else {
        console.warn('Canvas element not found in viewport.');
        setError('Viewer canvas not found.');
      }
    }
  };

  return (
    <div className="p-4"> {/* Padding around the component */}
      <h1 className="text-xl font-bold mb-4">Upload CBCT Scan</h1> {/* Title */}

      {/* File input for selecting the CBCT scan file */}
      <input
        type="file"
        accept=".mha,.nii,.dcm,image/png,image/jpeg" // Accept medical formats and common image types for direct testing
        onChange={handleFileChange} // Call handler when file is selected
        className="mb-4 block w-full text-sm text-gray-500 file:mr-4 file:py-2 file:px-4 file:rounded-full file:border-0 file:text-sm file:font-semibold file:bg-blue-50 file:text-blue-700 hover:file:bg-blue-100"
      />

      {/* Upload button */}
      <button
        onClick={handleUpload} // Call handler on click
        disabled={loading || !file} // Disable button while loading or if no file is selected
        className={`py-2 px-4 rounded text-white ${loading || !file ? 'bg-gray-400 cursor-not-allowed' : 'bg-blue-500 hover:bg-blue-600'}`}
      >
        {loading ? 'Processing...' : 'Upload and Process'} {/* Button text changes based on loading state */}
      </button>

      {/* Display error message if any */}
      {error && <p className="text-red-500 mt-2">{error}</p>}

      {/* Conditional rendering: Show viewer and tools only if responseData is available (image is ready) */}
      {responseData && (
        <div className="mt-4">
          {/* Display metadata from the backend response */}
          <p className="mb-4">
            <strong>CBCT Image Shape:</strong> {responseData.imageShape.join(', ')}
            {/* Display panoramic spacing if available from backend response */}
            {responseData.pixelSpacingX !== undefined && responseData.pixelSpacingY !== undefined && (
                <span> | <strong>Panoramic Spacing:</strong> {responseData.pixelSpacingX.toFixed(2)} x {responseData.pixelSpacingY.toFixed(2)} mm/pixel</span>
            )}
             {/* Add a note if using the default spacing (backend didn't provide it) */}
             {responseData.pixelSpacingX === undefined && responseData.pixelSpacingY === undefined && (
                 <span className="text-yellow-700 ml-2">(Using default 0.1mm spacing)</span>
             )}
          </p>

          {/* Annotation Toolbar */}
          <div className="flex flex-wrap gap-2 mb-4">
            {/* Buttons for selecting annotation tools */}
            <button
              onClick={() => handleToolChange(LengthTool.toolName)}
              className={`px-4 py-2 rounded text-sm font-semibold ${activeTool === LengthTool.toolName ? 'bg-blue-600 text-white' : 'bg-blue-400 text-white hover:bg-blue-500'}`}
            >
              Length
            </button>
            <button
              onClick={() => handleToolChange(BidirectionalTool.toolName)}
              className={`px-4 py-2 rounded text-sm font-semibold ${activeTool === BidirectionalTool.toolName ? 'bg-blue-600 text-white' : 'bg-blue-400 text-white hover:bg-blue-500'}`}
            >
              Bidirectional
            </button>
            <button
              onClick={() => handleToolChange(ArrowAnnotateTool.toolName)}
              className={`px-4 py-2 rounded text-sm font-semibold ${activeTool === ArrowAnnotateTool.toolName ? 'bg-blue-600 text-white' : 'bg-blue-400 text-white hover:bg-blue-500'}`}
            >
              Arrow
            </button>
            <button
              onClick={() => handleToolChange(EraserTool.toolName)}
              className={`px-4 py-2 rounded text-sm font-semibold ${activeTool === EraserTool.toolName ? 'bg-red-600 text-white' : 'bg-red-400 text-white hover:bg-red-500'}`}
            >
              Eraser
            </button>
             {/* Button to save the annotated image */}
             <button
              onClick={handleSaveImage}
              className="px-4 py-2 bg-green-500 text-white rounded text-sm font-semibold hover:bg-green-600"
            >
              Save Image
            </button>
          </div>

          {/* Cornerstone Viewport Element */}
          {/* This div is where Cornerstone will render the image and annotations */}
          <div
            ref={elementRef} // Attach the ref to this div
            className="w-full h-96 bg-gray-200 border border-gray-300 cursor-crosshair" // Styling for the viewport area
            onContextMenu={(e) => e.preventDefault()} // Prevent the browser's default right-click menu
          />
        </div>
      )}
    </div>
  );
};

export default ImageUpload;
